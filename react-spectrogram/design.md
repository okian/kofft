Modern PWA Spectrogram Design Specification
General Concept
We aim to create a modern, responsive Progressive Web App (PWA) that delivers an interactive waterfall spectrogram experience across devices. The design will be clean, minimal, and coherent, inspired in part by the functional simplicity of Adobe Audition’s interface and the Bauhaus design ethos of form-follows-function
medium.com
medium.com
. Every UI element – from layout to color to typography – will be carefully chosen for usability, clarity, and visual appeal. The interface should scale seamlessly between a large desktop monitor, a tablet like the iPad, and a small smartphone screen, automatically adapting its layout. The overall aesthetic is simple but beautiful: neutral backgrounds, bold accent colors, intuitive icons, and a consistent style throughout. No detail is left to imagination – every component’s size, color, margin, and padding is specified for a harmonious, modern look.
Layout & Responsiveness
Main Structure: The app is divided into four primary regions arranged in a flexible grid or flexbox layout: a top header bar, a central spectrogram content area, optional sidebars (for metadata and playlist), and a bottom footer for controls. This structure adjusts based on screen size:
Header/Top Bar: (Optional and minimal.) At the very top, a slim header (around 50px height on desktop, 40px on mobile) contains the app logo or title on the left and a few key icons on the right (for example: a file open/upload icon, a microphone toggle icon, a settings gear). The header uses a neutral background (e.g. a dark gray #212121 in dark theme or light gray #f0f0f0 in light theme) with high-contrast text/icons (white or black) for visibility. Padding inside the header is ~10px, ensuring the logo and icons are not touching the edges. On small screens, the header might collapse to just an icon or a hamburger menu for space, or be entirely omitted if not needed (since controls can exist elsewhere). The header’s design is minimalist – no thick borders or excessive ornamentation – aligning with the Bauhaus preference for clean lines
medium.com
. If present, it might have a subtle bottom border or shadow to distinguish it from the content area.
Main Content (Spectrogram Display): The spectrogram canvas occupies the majority of the screen. On large screens (laptops/desktops), it is centered, flanked by sidebars. On smaller screens, it expands to full width once sidebars are hidden. The content area has a responsive width and height: it should stretch and shrink with the window, always maintaining enough space to display the spectrogram clearly. For instance, on a desktop with a sidebar on each side (each ~250px wide), the spectrogram area could take the remaining width (flexible, e.g. if window is 1200px wide, spectrogram area ~700px after sidebars). On a tablet, if sidebars are collapsed, the spectrogram might take nearly 100% of the width (minus some padding), and on a phone it’s 100% width. Vertically, the spectrogram area extends from below the header to above the footer. There should be a small margin or padding (perhaps 10px) around the spectrogram canvas so it isn’t flush against other elements, giving it room to breathe. The layout uses CSS Flexbox or CSS Grid to automatically adjust these proportions; for example, a grid template might define columns for [sidebar-left] [main] [sidebar-right] where sidebar columns can collapse to 0 width on small screens. All resizing happens fluidly – if the user resizes the window or rotates a device, the spectrogram canvas smoothly scales to fit the new size without distortion (maintaining aspect ratio of frequency vs time scale appropriately).
Sidebars (Metadata & Playlist): Two side panels provide additional info, each roughly 250px wide on desktop (or about 20% of window width, whichever is smaller). These sidebars are collapsible to accommodate smaller screens:
On laptops/desktops, both the left sidebar (metadata details) and right sidebar (playlist) are visible by default, framing the spectrogram. They have a consistent background color (slightly contrasting the main background, e.g. a dark theme might use #2b2b2b for sidebars against a black main background, to subtly delineate them) and share the overall design language (same typography and colors). They are separated from the spectrogram area by a thin divider line or subtle shadow.
On tablet (iPad) screens, these sidebars start collapsed/hidden to prioritize the spectrogram. Each sidebar can be toggled open via a button or keyboard shortcut (e.g. pressing M for metadata, P for playlist). When opened, they could slide in as overlays or push the spectrogram aside. The transition should be animated (e.g. a 0.3s slide-in with ease-in-out). Users can tap the screen or the toggle button again to collapse them. Only one sidebar might be shown at a time on smaller tablets to preserve space.
On iPhone/phone screens, the layout becomes a single column: the spectrogram fills the top part of the view, and the footer controls are at the bottom. The metadata and playlist are accessed via slide-in drawers or modals instead of persistent side panels. For example, tapping an “Info” icon could slide up a metadata panel from the bottom or slide in from the side, covering the spectrogram temporarily. Similarly, a “Playlist” icon (perhaps a list icon) opens the track list. These overlays on mobile should typically take up most of the screen (maybe ~90% height) to show content comfortably, and include a clear close button or swipe-down gesture to dismiss. When hidden, only their icons are visible in the header or footer. This way, on a phone the user primarily sees the spectrogram and playback controls, with other info on-demand.
Footer (Playback Controls): A persistent footer bar spans the bottom of the screen, height about 60px on desktop, slightly larger (~70px) on mobile for easier touch interaction. It has a background color matching or slightly darker than the header (for example, dark theme: pure black #000 or a very dark gray, with semi-transparent backdrop if we want a slight overlay effect). The footer contains all playback and navigation controls (details in Playback Controls section). It remains visible at all times; even if the sidebars are open or on small screens when scrolling, the footer can be fixed to the bottom (using CSS position: sticky or fixed) so that playback controls are always quickly accessible. On mobile, the footer might be the only persistent UI element aside from the spectrogram, effectively acting as a control strip. The footer’s content is centered and padded (at least 10-15px padding on left/right ends so controls don’t touch screen edges). If the app is scrolled (in cases where spectrogram or lists overflow vertically), the footer stays docked at bottom (scrolling the spectrogram behind it if needed). This guarantees that play/pause and other vital controls are one tap away at any time.
Responsive Design Summary: We utilize CSS media queries or responsive units to adjust layout at common breakpoints:
Desktop: If width > ~1024px, show both sidebars. Spectrogram occupies the central region (with maybe a fixed height equal to the remaining space between header and footer – e.g., if viewport height is 800px, with a 50px header and 60px footer, spectrogram gets ~690px height). There is ample horizontal room for the spectrogram and legends.
Tablet: If width ~768-1024px, possibly show only one sidebar at a time or collapse both by default. The spectrogram expands, and sidebars become overlay panels toggled by icons/shortcuts. All text and controls might scale slightly larger for touch.
Phone: If width < 768px (or explicitly detected as mobile), switch to single-column: hide sidebars behind modals/drawers, possibly hide the header or simplify it (e.g., only a menu icon and title). Increase touch target sizes (buttons at least 40px in tap size). The spectrogram might have slightly smaller text labels on axes to fit, or possibly hide non-critical labels to avoid clutter on a tiny screen. The design ensures no horizontal scrolling is needed; everything fits naturally in the narrower width by stacking elements vertically and using collapsible components.
Flexible Width/Height: All components use relative sizing or CSS flex/grow so that the app can run in a small window or as a fullscreen app. The spectrogram canvas should dynamically resize to fill available space while maintaining smooth rendering (the canvas can use resolution matching its display size for clarity, possibly adjusting resolution on resize to avoid blurriness). No fixed pixel width for major components (except perhaps minimums, like a sidebar might have a min-width of 200px when open to remain usable, and the footer a fixed height). The UI avoids any content overflow or overlapping at common resolutions – tested from ~320px wide (small phone) up to 4K monitors. Margins and padding scales should be chosen to look good at various DPIs (making use of CSS rem or vw units for proportionate spacing could help). The design grid system takes inspiration from Bauhaus principles, using geometric alignment and balanced spacing to create order and coherence
medium.com
 – for example, an 8px base spacing unit, so that padding and gaps are consistently 8px, 16px, 24px etc., giving the interface a harmonious, structured look.
Spectrogram Area
Waterfall Spectrogram Display: The core of the app is a real-time waterfall spectrogram occupying the central area. This spectrogram is a scrolling visual representation of audio frequency content over time:
Frequencies are plotted on one axis (usually the vertical axis), and time progresses along the other axis. In our design, we choose a waterfall style where new data appears continuously and pushes old data in one direction. For example, time can flow from top to bottom (newest audio at the top, cascading downwards like a waterfall) or left to right; a common approach is top-to-bottom scrolling so that the latest moment is always at the top of the spectrogram. We’ll implement it such that the spectrogram scrolls smoothly in real time – as audio plays or microphone input comes in, new spectral lines are drawn and gently move the older content down (or left) rather than updating in choppy jumps. This smooth movement (akin to a live radar or sonar display) provides an immediate, fluid visual of the sound. The frame rate and drawing method will ensure no stutter; ideally aiming for 60 FPS updates so the motion and color changes appear continuous. This means efficient canvas rendering or WebGL usage under the hood (with WASM FFT computations already in place).
Dimensions & Scaling: The spectrogram should automatically resize with the app window. On a large desktop, it may be a large canvas (e.g., 800px width x 600px height or more), whereas on a phone it might be ~320px wide x 400px tall. Regardless of size, the aspect ratio of the spectrogram’s axes should remain sensible – e.g., frequency axis should not be squashed too much. We may allow the user to zoom or adjust scale if needed, but by default it fills the available area. The canvas or SVG element for the spectrogram can use a high resolution (devicePixelRatio scaling) to remain crisp on high-DPI screens.
Color Themes: The spectrogram supports multiple color themes to suit different preferences and lighting conditions. Themes include:
Dark Theme (Default): A charcoal or black background (#000000 to #1a1a1a) with a high-contrast color palette for the spectrogram data. For example, frequencies could be displayed in a heatmap from dark blue for low intensity up to bright yellow or orange for high intensity (similar to Adobe Audition’s default spectrogram colors). Alternatively, a neon palette can be used on dark (like low intensities in deep purple, mid in teal, high in neon lime or bright yellow). The dark theme aligns with professional audio software aesthetics and is easy on the eyes in dim environments.
Light Theme: A light gray or near-white background (#f9f9f9 or #ffffff) with correspondingly adjusted spectrogram colors (e.g., using darker colors for data so they stand out on light background – perhaps shades of blue to red on a light canvas). The light theme is useful for bright environments or user preference. All text (axes, labels) would be black or dark in this mode for contrast. Ensure that even in light theme, the intensity colors are distinct (for instance, avoid very light yellows that might be hard to see on white).
Neon Theme: A stylistic dark-based theme with pure black background and extremely vibrant neon colors (electric blues, greens, magentas) for the frequency data. For example, quiet sounds might be a transparent black, while louder sounds glow in neon blue or green, evoking a retro-futuristic look. This theme can be eye-catching and fun while still maintaining clarity.
High Contrast Theme: Aimed at accessibility, perhaps using a very limited palette (e.g., black background and white or bright single-color spectrogram). This could render intensity in just one hue with varying brightness, or a bold two-color scheme (for instance, nothing vs bright green). The goal is to ensure readability for those with visual impairments or in very difficult viewing conditions. All text and UI elements here would also maximize contrast (white text on black, etc.).
Users can switch themes easily, and the UI elements outside the spectrogram (backgrounds, panels, text) will also adapt to match the chosen theme (for example, switching to light theme will make all panels light and text dark). Each theme is carefully designed to be coherent and aesthetically pleasing, with colors that complement each other. We also ensure color choices meet accessibility guidelines (sufficient contrast between text and background, distinguishable colors for colorblind users in the high-contrast mode, etc.).
Legends & Labels: The spectrogram area includes a legend for frequency and a color scale for intensity:
A frequency axis label is shown (e.g., along the left edge if time is horizontal, or along the bottom/top if time is vertical). For example, if frequency runs 0 Hz at bottom to 20 kHz at top in a vertical orientation, the left side of the spectrogram will have tick marks or labels at logical intervals (0, 5k, 10k, 15k, 20k Hz). If a logarithmic scale is selected, the ticks might be at 100 Hz, 1k, 5k, 10k, etc. These labels use a small, clear font (perhaps 12px sans-serif) and a color that contrasts with the spectrogram background (white in dark theme, black in light theme). They might be positioned just outside the spectrogram grid or even overlaid semi-transparently on the edge of the canvas.
A time axis could be labeled as well, although in continuous scroll it’s less straightforward. If the spectrogram scrolls top-to-bottom, the horizontal axis is frequency and vertical is time; we might periodically annotate the time (like seconds or timestamps) on the side as it scrolls, or perhaps a moving time indicator line. If we are dealing with a loaded file (not live mic), and user seeks around, then a fixed time axis scale could be shown at top (like 0:00, 0:10, etc.). In a live scenario, maybe an indicator for “Live” or relative time.
An intensity color scale (legend) can be displayed to help interpret colors. This could be a small vertical bar or gradient strip placed in a corner of the spectrogram panel (e.g., top-right corner). It would show the gradient of colors from low intensity to high intensity, with numeric labels (for amplitude or dBFS values). For instance, if using dB scale, it might label -80 dB (soft) at the low end of the scale and 0 dB (loud) at the high end. The legend itself should be subtle – perhaps only appears when you hover a small “legend” icon or it’s tucked to the side so as not to clutter the view. But it’s very useful for a user to quantitatively understand the color mapping.
Interactive Tooltips & Indicators: The spectrogram is interactive. When the user hovers the mouse over the spectrogram (or taps on a point on touch devices), an on-hover tooltip appears showing the exact frequency and intensity at that point (and possibly the time). For example, if the user points at a specific streak in the spectrogram, a small floating label might say “Frequency: 440 Hz, Amplitude: -20 dBFS” (units adjusting to whatever format is selected). This tooltip would have a subtle, non-intrusive style: perhaps white text on a semi-transparent dark background, with a tiny arrow pointing to the data point. It could fade in and out as the pointer moves in/out. On desktop, additionally a crosshair line might follow the cursor (a horizontal and vertical line across the spectrogram) to help align with the axes values; on mobile, maybe a tap-and-hold could lock a crosshair and show the tooltip. These indicators help users read the spectrogram precisely. They should be implemented efficiently so as not to disrupt the continuous rendering (e.g., using overlay canvas or DOM element updated on pointer move).
We also consider adding interactive selection or zoom gestures: for example, click-and-dragging on the spectrogram could let the user select a time-frequency region (though since our app is more for visualization than editing, this might not be necessary). If implemented, a selection might highlight a rectangle region, which could then trigger some action (like zooming into that region, or showing stats). This is an extra feature and would be optional to include. At minimum, the user can pause the spectrogram (via Pause) and then inspect a static area with the tooltip.
Settings Module (Spectrogram Settings): By pressing S (or clicking a gear icon likely located near the spectrogram or in header/footer), the user can open a Spectrogram Settings panel. This panel allows customization of the spectrogram’s technical settings and theme:
Theme Selection: Options to choose among the provided themes (Dark, Light, Neon, High Contrast, or even a Custom if we allow user-defined colors). This could be a set of radio buttons or a dropdown menu. Each option might show a tiny preview or description.
Amplitude Scale Format: A toggle or dropdown to switch between raw amplitude, magnitude, or decibel (dBFS) scaling for the intensity. This affects how the colors are computed from the audio signal. For example, dBFS (decibels relative to full scale) is logarithmic; amplitude and magnitude might be linear. The UI might present it as “Intensity Scale: [Amplitude | dBFS]” or “Color Intensity Represents: [Linear | Logarithmic]”, depending on what makes sense to a user.
Frequency Scale (Linear/Log): A switch for the frequency axis scale. Linear means equally spaced frequencies; logarithmic means more detail in lower frequencies (common in audio). This choice will immediately update how the spectrogram is rendered and how the frequency labels are shown.
Resolution: A setting to adjust the FFT size or time resolution. This could be a slider or stepper (e.g., “Spectrogram Resolution: [Low – High]”) which under the hood might increase the FFT length or pixel density. Higher resolution shows more frequency detail (and maybe slower update rate or more processing), lower resolution might run faster. We can label it in user-friendly terms (like “Detail Level”).
Refresh Rate: Perhaps a slider or dropdown to choose the refresh frame rate or interval for updating the spectrogram. For instance, options like 30 FPS, 60 FPS, etc., or a quality vs performance toggle (Smooth vs Power-saving).
Possibly other settings like Colormap selection (especially if custom theming or different predefined colormaps beyond just theme, e.g., “Rainbow”, “Heatmap”, etc.), or toggling the legend visibility, etc. If many settings exist, group them with subheadings in the panel.
The settings panel itself should be styled consistently: it might appear as a modal dialog centered over the app or as a side drawer from the right. A modal might have a translucent overlay behind it to dim the background. It should have a clear close button (like an X at top-right or a “Done” button at bottom). The panel background would be the same neutral color as sidebars (maybe slightly more elevated with a drop-shadow to indicate it’s above the main UI). Form controls (sliders, checkboxes, dropdowns) should use the same accent colors and typography. There should be ample padding (~20px) inside the settings dialog so it doesn’t feel cramped. Each option can have a label (maybe in a slightly larger or bold font) and the control next to it. Use consistent spacing (like 10px between each option row). If it’s a side drawer style, it could slide from the right edge, covering about 300px width on desktop (full width on mobile). Animations: The panel should animate into view smoothly (fading and sliding). Once adjustments are made, the spectrogram updates live behind the panel if possible, to preview changes. Users can hit Esc or click outside to close it as well.
Snapshot Feature: Users can capture the current state of the spectrogram as an image. The UI will provide a shortcut Ctrl/Cmd + Shift + S for quick access, and possibly a small camera icon button either in the header or floating over the spectrogram area. When triggered, the app will take the current spectrogram canvas and save it as a PNG or JPEG image. The design for this feature:
The camera icon button (if present) will be intuitive (a simple outline of a camera or screenshot icon) and placed non-intrusively (perhaps in a top corner of the spectrogram area, semi-transparent until hovered, or in the header bar if space allows). On mobile, it could be in a hidden menu or simply rely on the hardware screenshot or a long-press context menu due to limited space.
When the user takes a snapshot, provide visual feedback: for example, a quick flash overlay on the spectrogram to mimic a camera flash, or an animation of the image thumbnail flying out (indicating it saved). A small toast message could appear like “Snapshot saved!” (if it automatically downloads the file or saves to gallery on mobile).
The saved image file can be named with a timestamp and maybe the track name if applicable (e.g., spectrogram_snapshot_2025-08-17T12-55-00.png).
If multiple themes are available, the snapshot will capture whatever theme/coloring is currently active – essentially a direct screenshot of the spectrogram area including the frequency axis and color legend if visible.
Optionally, we might allow snapshots to either include the entire UI or just the spectrogram. Probably just the spectrogram is needed, but if including axes labels is helpful, ensure those are drawn on the canvas or assembled into the image.
The snapshot feature encourages exploration and sharing, so it should be easy to use. The PWA should handle saving in a way that works on all devices (using download on desktop, using the Filesystem or sharing API on mobile if possible). From a design perspective, the main considerations are the placement and visibility of the snapshot control and the confirmation feedback when it’s used. We keep the icon small and unobtrusive so it doesn’t distract during normal use, but still discoverable (maybe a tooltip “Save image” appears on hover or a label on long-press).
In summary, the spectrogram area is the focal point of the UI, with a design that emphasizes smooth real-time visuals and user control over how it looks. The dark, modern aesthetic (in default mode) with vibrant spectral colors and minimal clutter reflects a professional tool vibe (like Adobe Audition’s spectral view) but simplified for a PWA. All interactive elements (tooltips, settings toggles) are there to enhance understanding without overwhelming the visual of the spectrogram itself.
Playback Controls (Footer)
The footer hosts the playback controls which are always visible at the bottom of the app. Its design balances functionality and simplicity, making sure both mouse and touch users can easily control playback. The footer is typically a 50-60px tall bar (desktop) or slightly taller for touch devices, stretching full width. Inside, elements are laid out with logical grouping and spacing:
Play/Pause & Transport Controls: At the center (or slightly to the left of center) of the footer, we present the basic playback buttons:
Play/Pause: a single toggle button that shows a “Play” icon (classic right-pointing triangle) when media is paused, and a “Pause” icon (two vertical bars) when media is playing. This is the primary control, so we make it stand out: for instance, it could be 1.5× larger than the other icons (e.g., 32px icon while others are 24px). It might also use the accent color to draw attention (e.g., in a neon theme, the play button glows neon blue when hovered or active). The button itself could be a circular shape with the icon in the middle – we can give it a round background on hover or always (depending on style). Rounded corners or circular buttons tie into the modern design (and are touch-friendly). When hovered/clicked, it could slightly animate (e.g. depress inwards or scale 0.95 for a moment) to provide feedback.
Stop: a square icon representing stop. This will halt playback and reset the track to the beginning (and perhaps also freeze the spectrogram until play is pressed again). The stop button can be placed near the play (commonly to the right of play/pause). It can be slightly less prominent (maybe the same size as other icons). If space is tight, one might consider omitting stop (since pause + seeking back can suffice), but since it’s listed, we include it.
Previous Track / Next Track: Icons with double-arrows (backward << and forward >>). Placed on either side of the play button (prev on the left of play, next on the right of stop, or symmetrical around play). These allow skipping tracks in the playlist. They should be smaller or equal size to the stop icon (around 24px) and have consistent styling (line style or filled same as others). They also need to be sufficiently spaced to avoid accidental presses – e.g., at least 16px gap between play and next/prev. On mobile, we’ll ensure there’s even more spacing or that these icons are not too close to the screen edge.
These transport controls might be grouped together visually. For example, they could sit on a slightly raised portion of the footer or a translucent panel within the footer for emphasis. Alternatively, a simple layout with equal spacing is fine. The key is to maintain a balanced alignment. Often, a music player will center the play controls as a cluster. We can center the play/pause exactly at 50% width of the footer, with prev to its left and next/stop to its right spaced evenly.
Seek Bar: The seek bar spans across the footer (likely above or integrated with the playback buttons section). Instead of a simple flat progress slider, here it is envisioned as a waveform-inspired timeline – a row of vertical bars, each bar’s height representing the audio amplitude at that segment of the track. This creates a miniature waveform view of the entire track:
The seek bar might extend almost the full width of the footer (with some margin on the sides for aesthetics, e.g., 10px from each edge). It could be positioned just above the main buttons, or even behind them if using an overlay approach. A straightforward implementation is to place it as a separate element above the controls: e.g., a thin bar area ~10-15px tall that contains the waveform.
The waveform bars are narrow vertical rectangles (maybe 2-3px width each) separated by a 1px gap (giving that slight padding between bars). They have slightly rounded tops for a softer look (border-radius on the bar tops maybe 1-2px) so they appear as a series of smooth spikes rather than hard rectangles. The entire waveform could consist of, say, 100 bars representing the track’s duration (the number can scale with track length or screen width; more bars for longer tracks or higher resolution screens).
Color: Bars for portions of the track that have already played can be drawn in a filled accent color, while upcoming bars (not yet played) are in a more subdued color. For example, in dark theme, played part might be a bright teal or blue, and unplayed part a gray or dimmed blue. This dual-color approach makes it clear where the current play position is. Alternatively, the bars could all be one color but with a distinct progress indicator overlay or a highlighted current bar.
Progress Marker: We can highlight the current position with a vertical line or by differentiating the bar at the current time (e.g., making it a slightly different shade or a bit thicker). Some designs use a small handle or dot that moves along the top of the waveform; however, since our waveform itself is segmented, it might suffice that the segmentation inherently shows progress.
This waveform seek bar is interactive: the user can click or tap anywhere on it to seek to that point in the track. When hovering (on desktop), the section under the cursor could highlight subtly (maybe show a tooltip of the timestamp if desired). On mobile, tapping jumps immediately. To ensure good usability, even though the waveform bars are narrow, the whole bar area can be given a taller transparent hit area (e.g., 20px tall) so touches are captured easily even if the visual is 10px tall.
The waveform should be generated from the audio file’s data (since the functionality for FFT exists, we can perform an offline analysis to get the amplitude envelope across the track). Possibly the WASM FFT can be repurposed to compute an approximate waveform (perhaps by summing frequency bands or doing a time-domain downsample). The design doesn’t need to show the exact FFT output here, just amplitude over time is enough. The result could be precomputed when a file loads and then rendered as an SVG or canvas or even a series of divs styled accordingly.
Buffering: If streaming or not fully loaded, parts of the waveform might not be known – in that case, we might visually distinguish buffered vs unbuffered portions (e.g., buffered part in a slightly different shade). But since for local files we likely load entirely, this may not apply.
The background of the seek area can be transparent or a very slight different color than the footer to set it apart. Possibly we embed the waveform on a subtle grid or a slight shadow to make it pop.
For additional clarity, we can include time labels on either side of the seek bar: current time elapsed on the left, and total duration on the right. For example, “1:23 / 3:45”. These can be small text (12px) below or above the waveform. This was not explicitly asked, but it’s a common UI pattern that enhances usability. If added, they should be low-key (perhaps only on desktop or as an option) so as not to clutter the minimal design.
Volume Control: Positioned typically on the right side of the footer (on LTR layouts) or left side. For instance, we could place volume on the far right end of the footer bar for desktop. It consists of a speaker icon and a volume slider:
The speaker icon indicates volume/mute state. It could change icon based on volume (full speaker for high volume, a half icon for low, and a mute icon (speaker with an X) when muted). This icon is clickable: clicking toggles mute on/off. The icon size ~20px, and it’s placed with maybe 8px margin from the end of the slider.
The volume slider is a horizontal track with a small knob. Because the footer is not very tall, a horizontal slider works nicely, about 80-100px long on desktop. On mobile, instead of a slider (which can be hard to manipulate if very small), we might simply rely on hardware volume or use the up/down arrow shortcuts; but if we include it, we might make it a shorter slider or even a pop-up control (for example, tapping the speaker icon could reveal a vertical slider).
The slider track color could be a neutral gray, with the filled portion (from left up to the knob) in the accent color (e.g., blue). The knob itself can be a small circle (8-10px diameter) that’s easy to grab. We give it a border or a distinct color so it’s visible (e.g., white fill with blue border on dark background).
We ensure the volume control also has enough padding around it – e.g., not too close to the seek bar or the right screen edge, to avoid accidental touches. If needed, on mobile we might omit the text slider and just show the icon which when tapped toggles mute or opens a bigger slider control.
Arrangement & Spacing: The footer’s content should be arranged logically: for example, left side could have a “Now Playing” text or just be empty, center has the transport, right side has volume. But with the addition of a wide seek bar, a good approach is:
The waveform seek bar sits as a layer that stretches almost full width above the rest of the controls (or integrated but visually separate). Underneath it (or over it) the transport controls cluster can be centered.
We might allow the waveform to occupy the same horizontal line as some controls if we carefully position them. Alternatively, a slightly taller footer can accommodate the waveform and controls without overlap. For clarity, imagine a two-row footer: top row (thin) is the seek waveform and maybe time labels; bottom row is play/pause and other buttons. This could be achieved with a 60px footer that contains a 15px high waveform area at top and a 45px controls area below. However, to keep design simple, we might overlay the play controls on the waveform area but ensure the waveform is still visible around them.
Each button/icon has consistent margin: e.g., each control button could have 16px space to the next. The play/pause, being larger, might have a bit more gap so it doesn’t feel cramped. The volume slider might be separated from the next control by more space (like 24px) to visually distinguish the group.
The entire footer likely uses a flex container: for example, we can have three segments (left, center, right). Center contains play controls, left could contain maybe an app icon or track title if we want (though track title could also show in metadata sidebar, but on mobile we might want the current track name marquee in the footer). If track title is shown in footer, it would be truncated with “...”, maybe centered or left-aligned. Since the user did not specify, we won’t assume a title in footer, as it’s in metadata. So left segment can just be empty or part of the seek bar. Using flexbox, center segment can be auto-sized to fit controls, and the seek bar can actually be a background element spanning the whole footer behind these segments.
Touch considerations: All interactive elements meet a minimum target size (~48px recommended). Our icons at 24px with padding around effectively yield about 40-50px clickable area which is good. We can add invisible padding/hit area if needed to each icon. The volume slider knob may be tiny, so on mobile a different UI (like tapping the icon cycles volume levels or opens a bigger slider popover) might be considered.
Visual Style: The footer background color as mentioned is neutral/dark (depending on theme). If dark theme, maybe a slightly darker shade than the main background to give it prominence (e.g., #1a1a1a main, #111 for footer). Or we could use a slight translucency so the spectrogram can be glimpsed behind the footer – but that might reduce contrast for controls, so probably a solid color is safer for clarity. Controls icons are typically monochrome (white in dark theme, black in light theme) but with states: on hover or active, they could glow or change to the accent color. For example, hovering the play button could turn it into the theme’s primary accent (e.g., bright blue). When actually playing, the pause icon might stay in accent color indicating active state.
We’ll use rounded corners for any button backgrounds (if we show a background on hover, etc.). The footer itself could have slightly rounded top corners (especially in a standalone mobile app context, a slight rounding at top of footer can be visually nice). But if it’s full width edge-to-edge, usually no rounding.
The icons likely come from a consistent icon set (such as Material Design icons or a custom set designed with thin outlines or simple fills). For a Bauhaus feel, one might use very geometric icons: e.g., triangle, square, and lines that look almost like basic shapes. As a subtle touch, we could style the play/pause/etc icons in a slightly unique way (maybe thicker line weights or an outline style) to match the typography weight. All icons will be vector (SVG or icon font) so they scale well.
Animations & Feedback: When the user interacts with the playback controls, there should be immediate visual feedback:
Clicking Play might not only change the icon to Pause but could also trigger a tiny animation on the icon (like a brief pulse or scale effect). Similarly, clicking Next might flash the next track’s info, etc.
The waveform seek bar should update in real time as music plays: a moving indicator or the bars filling should animate smoothly as time progresses. When seeking (user clicks on it), the change should reflect instantly – possibly with a small blink or highlight at the new position to confirm the jump.
The volume slider knob will move as volume changes (with a smooth transition if adjusted via keyboard).
If mute is toggled, the speaker icon changes (maybe animate between speaker icon and muted icon with a quick fade or slide).
All such micro-animations should be subtle and quick (100-200ms) to not distract but to provide a modern polished feel.
In essence, the footer’s playback controls are designed to be intuitive and attractive: they borrow from familiar music player layouts (including the SoundCloud-like waveform seek bar concept) and incorporate a consistent modern style (rounded elements, hover effects, clear icons). The user can control playback effortlessly on any device, with large enough buttons on touchscreens and informative visuals like the waveform and time indicators to enhance the experience.
Input Sources
Our PWA supports multiple audio input sources, and the UI provides ways to switch or combine these inputs seamlessly. The design covers file input, microphone input, and even a hybrid mode with both:
File Input (Audio Files): Users can load audio files via traditional file pickers or drag-and-drop, and queue up multiple files to play through:
There will be an “Open File” icon/button (for example, a folder icon or a music note with a plus) likely placed in the header bar or somewhere easily accessible. On desktop, clicking it opens a file picker dialog (accepting common audio formats). On mobile, it might trigger the OS file selection.
Drag & Drop: The design should accommodate drag-and-drop for convenience. This means when the user drags a file over the app, we can visually highlight the drop area. A possible implementation: if no file is loaded yet, the spectrogram area itself could show a dashed outline or overlay text “Drop audio file(s) here to load” when a file is dragged over. If a file is already playing, dragging a new file could still show an overlay or perhaps target the playlist panel (if visible). The drop zone can be the entire window for simplicity, but visually it makes sense to highlight the main content area.
When files are added, the app should update the Playlist sidebar with the new track(s). If multiple files are selected at once, they all get queued. The UI might show a brief loading indicator per file if they need to be decoded or analyzed (especially if we precompute the waveform for the seek bar, that might take a moment). A small progress bar or spinner could appear next to the track name in the playlist until ready. We aim to keep these indicators minimal – perhaps just a spinning icon replacing the track number.
Supported file types and any limitations (size, length) can be mentioned in documentation, not necessarily in the UI, to keep interface clean.
If a user opens a single file, playback can start automatically (or await a play press, depending on desired UX – might be better to await user pressing Play).
Metadata Extraction: Upon loading a file, if it contains metadata (ID3 tags, etc.), we will display that in the Metadata panel (title, artist, album, year, etc.). The album art, if embedded, will also show (this might require reading the file’s metadata in the background). If reading metadata takes time, we could first show the filename or “Unknown Title” and then update fields when ready. It’s a detail, but important for a polished feel.
In case a file cannot be loaded (unsupported format or error), the UI should show a friendly error message (possibly a toast notification or a message in the playlist item like “Error: could not load file”). Use clear, readable text in a warning color (maybe red or orange) for errors, and ensure it doesn’t break the layout.
The design for file input is mostly about the presence of the button and the drag-drop overlay. The Open File icon should be intuitive (maybe a combination of a folder and music note). We can place a text tooltip “Open audio files” on hover. On mobile, we might simply have a text button “Open” in a menu since hovering isn’t available.
Microphone Input (Live Audio): The app can directly take audio from a microphone in real-time, visualizing it on the spectrogram:
A Microphone toggle icon will be present (perhaps in the header next to the file icon, or even within the playback controls area). The icon would be a classic microphone shape. This acts as a button: if not currently listening to mic, it’s off (maybe just an outline icon); when activated, it could highlight (filled icon or glow) indicating live mode is on.
When the user first clicks the mic icon, the app will likely prompt for microphone permission. We should visually indicate this state – possibly by changing the icon to a waiting state (maybe blinking or a question mark overlay) or simply a pop-up message: “Allow microphone access to enable live input.” The design should consider that on desktop, the browser might show its own permission dialog; on mobile, similar. We can give a hint in the UI if possible. Once permission is granted, the mic icon can turn “on” (for example, turning red or the inside of the mic icon filled with the accent color) to show it’s capturing.
In live mode, the spectrogram should immediately start scrolling as it listens to ambient sound or whatever is captured by the mic. We might also show a small “LIVE” label in one corner of the spectrogram area (similar to how live broadcasts do) to remind the user that this is real-time audio. Possibly this could be a red badge or text in the top-left of the spectrogram canvas area.
If multiple input devices are available (for example, laptop mic vs external mic), we can provide a way to choose. This might be a small dropdown arrow next to the mic icon or an option in the settings panel. If using a dropdown, when the mic icon is clicked or right-clicked, a list of input sources by name (“Built-in Microphone”, “USB Mic” etc.) appears. The user selects one and then it activates. This UI should be straightforward: perhaps the mic icon has a tiny down-caret indicating more options. On mobile, this might be handled via a separate settings screen since dropdowns are tricky – maybe tapping the mic icon immediately uses the default input, and to change, the user must go into a settings modal to pick another source.
The microphone input essentially acts like “another track” but continuous. So the playback controls might not all apply in the same way. Play/Pause could effectively enable/disable the live feed (pause might mute the mic input temporarily, play resumes listening). Stop could fully turn off the mic (and maybe turn off the icon highlight). We should define what Play/Pause does in live mode for clarity: It might be simpler that the mic icon is separate – you click mic to start/stop listening independently of the play button. Alternatively, clicking Play while mic mode is on could be redundant. Perhaps we treat mic input mode as exclusive: If mic is on, the file playback is paused or unavailable. This is up to desired functionality, but the design can hint at exclusivity by maybe visually toggling states (when mic is active, the play button might grey out or vice versa).
Provide feedback for mic input levels: maybe the mic icon itself or somewhere in UI could show input level (like a small bar meter on the mic icon). For example, a subtle animation of the mic icon “bouncing” or changing fill based on loudness can reassure the user that audio is being received. This is not critical but enhances UX.
Considering mobile specifically: microphone input on mobile might conflict with playback (as you can’t easily separate them). But if someone wants to use it like a live spectrum analyzer app, the UI should make it easy: one tap on the mic icon and the spectrogram comes alive with environmental sound. If on battery, maybe a note that this uses more power (not as UI, but maybe documented).
Stopping the microphone input (clicking the mic icon again) would revert the app to an idle state (or back to file playback if something was loaded and paused). The spectrogram could either freeze or clear when mic stops. Freezing (leaving last frame) might be fine, with the “LIVE” indicator turning off. Clearing it could also happen to show it’s no longer live – perhaps better to freeze so the user can inspect last bit.
Hybrid Input (File + Mic simultaneously): An advanced feature allowing a file to play while also visualizing live microphone input (overlay or mixed):
If enabled, this means the spectrogram will show a mix of the two audio sources. The design should have a way to activate hybrid mode, perhaps a toggle in the settings or a special icon. This might be represented by an icon of two sources (for example, a small wave icon with a plus sign and a mic icon). Alternatively, it could be simply the state of having both a file playing (Play button active) and the mic icon active at the same time – i.e., just allow the user to press Play on a track and then also enable the mic.
We need to communicate clearly when both are on. Possibly both the Play icon and the Mic icon are highlighted at the same time. Maybe a label “MIX” or “Hybrid” could appear near the spectrogram or as a status text somewhere. However, too many indicators might clutter; it might suffice that the user intentionally enabled both and knows it.
Visually on the spectrogram, both sounds will simply sum together. There won’t be an obvious UI distinction between which frequencies come from the file vs mic (that’s a complex visualization problem outside our scope). But the purpose might be, for example, to compare an input against a reference track or to have a backing track and a live input simultaneously.
The volume mix between file and mic might need an adjustment control (maybe outside scope, but perhaps each could have its volume). If so, the design could include a small mixer control in settings: two sliders, one for file volume, one for mic volume, if we anticipate that need. If not, it will just mix at whatever relative volumes they have (maybe both 100%).
The UI must avoid confusion: for example, if the user hits Next track or Stop, what happens to mic? Possibly keep mic on until explicitly toggled off. We should ensure that one source’s controls don’t inadvertently disable the other except by user action.
This hybrid mode is a bit niche; for clarity we might include a note or tooltip when enabling it that both inputs will play. But since the user specifically asked, we include the design considerations but keep the UI straightforward (just allow both icons to be active). It might be a power-user feature toggled via an option (like “Allow simultaneous mic and file playback” in settings, default off to not confuse casual users).
In summary, the Input Sources mechanisms are designed to be simple and user-friendly: drag-and-drop for files, one-click for mic. The UI guides the user with clear icons and states (highlighted icons for active inputs, gentle prompts for permissions). Despite the technical complexity of handling multiple sources, the design keeps it coherent – the same clean style (icons from the same set, consistent color feedback). For example, the file icon and mic icon might both be lined up in the header with equal icon size and circular hover effect, visually indicating they are similar “input” actions. The transitions (like opening a file or enabling mic) are accompanied by small feedback (e.g., file loaded message, mic live badge) so the user is never unsure of what’s happening.
Metadata & Playlist
The app includes two informational side sections: Metadata (track info) and Playlist (queue of tracks). They share a similar panel design for consistency, each occupying a sidebar (metadata on the left, playlist on the right on a large screen). Both panels can be shown or hidden (toggled with keyboard or an on-screen control) to keep the interface clean when they’re not needed.
Metadata Section (Sidebar – Track Info)
This section displays details about the currently playing audio track and possibly the input status:
Content & Layout: When expanded, the metadata panel typically shows:
Album Artwork: At the top of the panel, a square image representing the track’s album cover or associated image. If the audio file has embedded album art, that image is displayed, scaled to fit a defined size (say 150px x 150px on desktop, maybe slightly smaller on tablet to fit, and around 120px on phone). The image container can have a subtle border or shadow to stand out (e.g., a 1px border in a neutral color or a soft drop-shadow against the panel background). We might round its corners slightly (maybe a 4px radius) to match other UI elements’ rounding, unless a square look is desired. If no album art is available, a generic placeholder image is shown instead – for example, a simple graphic of a vinyl record or music note on a neutral background. The placeholder should be stylized to match the app’s theme (maybe a gray outline icon of a music note on dark theme, or a dark icon on light theme) and not too visually loud. It’s essentially a fallback so the UI doesn’t look empty; it can even just be the app’s logo or a waveform icon.
Track Title: Below the artwork, the track’s title is displayed prominently. Use a larger font size (e.g., 16-18px on desktop, slightly larger if needed on small screens for readability, perhaps 5% of screen width as a guideline). It should likely be bold or semi-bold. If the title is long, it should either wrap to two lines (max) or be marquee/ellipsized. Centering the title versus left-aligning: left-align is often better for readability in side panels, but if the design prefers a centered look under the album art, that can be done (center alignment could look neat if the album art is centered too). We must ensure there’s enough padding (at least 8px) between the artwork and the text.
Artist & Album: Following the title, the artist name and album name are shown (each on their own line, or combined on one line separated by a hyphen, depending on space and preference). These are in a slightly smaller font (maybe 14px) and possibly a regular weight (not bold, since title is bold). We might italicize or use a lighter color for album name to differentiate from artist – or simply prefix them with labels like “Artist:”, “Album:” if clarity is needed. But a cleaner approach: Artist – Album on one line if it fits, otherwise two lines.
Additional Info: Beneath that, smaller text for metadata like Year, Bit Rate, Sample Rate, etc. These can be presented as a list or a brief paragraph. For example:
Year: 2021
Bit Rate: 320 kbps
Sample Rate: 44.1 kHz
Each item could be on its own line, or some could be combined (like bit rate and sample rate on one line, since they are technical details). Use an even smaller font (12-13px) for these so they don’t compete with title/artist. They can be slightly gray in color to de-emphasize them (but still readable contrast). Maybe use icons for some (a calendar icon for year, a music file icon for bit rate?) – although icons might clutter; text labels are fine in a minimalist design.
If the input is microphone, the metadata panel might instead show “Live Input: Microphone (device name)” in place of track title/artist, and possibly a level meter or some indicator. If we want to cover that: we could have logic that if mic is active (and no file), the panel displays info about the mic (e.g., “Input: Built-in Microphone” and maybe sample rate of capture). But this is extra; since the user specifically enumerated track info fields, we focus on file metadata primarily.
The panel content should scroll if it exceeds the viewport (for example, if we also decided to show lyrics or long comments, but currently we just have a small set of fields – likely no scroll needed unless on a tiny screen).
Style: The background of the metadata panel is a neutral solid color (maybe slightly different from main background to delineate it). In dark theme, perhaps a dark gray (#252525) panel on a black background, or the same but with a subtle border line on the right edge to separate from the spectrogram. In light theme, maybe a white panel on a light gray background with a subtle shadow. The panel should visually integrate, not looking like a completely separate widget – same font and color palette.
All text in the panel will use the same sans-serif font as the rest (e.g., Inter or Roboto). We maintain a clear hierarchy: title largest, artist/album medium, other info small.
Margins/padding: inside the panel, we give content breathing room. For example, a 16px padding on all sides inside the panel ensures text isn’t glued to the edges. The album art could be centered horizontally with maybe automatic top margin. Or we put the album art at top with maybe 16px margin from top inside panel. Space between each text element (title to artist, etc.) maybe 4px or 8px as appropriate to visually group them.
If the panel height is more than content, it can have some padding at bottom as well so it doesn’t look like content is stuck at top only. A balanced vertical spacing is nicer.
Collapsibility: The metadata section is collapsible to maximize spectrogram area when needed.
On desktop, the collapsed state might be a thin vertical strip on the left edge of the window – perhaps just a slim bar (around 30px wide) showing an icon (like an “info” (ℹ️) symbol or a double-arrow). This acts as a handle; clicking it expands the panel out to full width. The collapse/expand could be animated (width transition). On collapse, tooltips can show “Show Track Info (M)” on hover as a hint. On expand, the strip disappears as the full panel is shown, and maybe an overlapping button or the same strip at the edge now with an arrow pointing the other way to collapse again. Alternatively, the panel could slide completely off-screen and we overlay a floating round “info” button somewhere (but a consistent approach with a strip or tab is clearer).
On tablets, the metadata panel likely starts collapsed. The user can tap a button or perhaps a swipe gesture from the left edge could open it (if we implement gesture support). The panel might overlay over part of the spectrogram rather than push content, since on a mid-size screen pushing might shrink spectrogram too much. So on tablet, expect it to slide over the spectrogram at maybe ~80% of screen width, leaving a bit of spectrogram visible to the right as context (or just full overlay if easier). We provide a semi-transparent backdrop behind it to focus attention. The user closes it by a close X or by tapping outside the panel.
On phones, as mentioned, we probably won’t have a persistent sidebar at all. Instead, an Info button somewhere (maybe in the footer or a floating button at bottom corner) will trigger a full-screen modal with track details. That modal essentially contains the same info (art, title, etc.) but likely in a single column view with larger text (for readability on small screen). It could even be combined with the playlist in one view via tabs or sections, but we can keep them separate: Info modal and Playlist modal separate for simplicity. The Info modal design on mobile: maybe the album art is large (taking top half of screen), and text below, with a big close button on top bar. The style remains consistent with the desktop panel albeit rearranged.
Additional Metadata & Future Ideas: If the design were to include more metadata (like waveform or spectral characteristics, lyrics, comments, etc.), the panel should be flexible. For now, it covers basic ID3 info. One could consider allowing editing metadata if this were a full app, but that’s out of scope here (we are focusing on display).
Overall, the metadata panel provides a quick glance of what’s playing, in a nicely formatted way. It complements the spectrogram by giving context (song name, artist) and satisfies the user’s need for that info without having to dig elsewhere. The design ensures it’s coherent with the rest of the app – same color scheme and typography – and easily shown or hidden as needed (non-intrusive).
Playlist Section (Sidebar – Queue)
This section shows the list of audio tracks that have been loaded or queued, allowing the user to see upcoming tracks and control playback order:
Content & Layout: The playlist panel, when expanded (on the right side in desktop view), displays a vertical list of tracks. Each entry in the list (one per track) includes identifying info and perhaps controls:
At minimum, each list item will show the Track Title. If space allows, we might also show the Artist or Duration. We could format it as “Title – Artist” on one line and maybe duration aligned to the right. Or two-line entry: first line Title, second line smaller font Artist and duration.
We can number the tracks or use bullet points. Numbering (1, 2, 3, …) can be helpful to know the order at a glance. The number could be a separate text or simply the list index if naturally shown.
If the list is long, the panel becomes scrollable (vertical scrollbar). We should style the scrollbar minimally (on WebKit we can make it thin, maybe only show on hover, etc., to keep the look clean).
Reordering: To support drag-and-drop reordering, each list item could have a “handle”. Typically, this is shown as an icon with three horizontal lines (like a grip). We might place that at the left of each item. Users can click and drag that handle up or down to move the track in the list. During drag, maybe the item is highlighted or semi-transparent and other items adjust accordingly (this is interaction detail, but important for usability). On touch devices, drag reordering can be done by long-press on the item and then drag – so we need a visual indication that it’s draggable (the handle icon helps, but on mobile it might not be visible; long-press feedback like slight lift animation can be used).
Removing Tracks: Each item might have a small “X” or “remove” icon, perhaps on the far right of the entry. On hover (desktop) the remove icon appears (to keep it clean otherwise), or always visible but dim until hover. On mobile, maybe a swipe gesture is used: swiping a track to left could reveal a Delete button (a common mobile pattern). We should confirm deletion with an “Undo” option possibly via toast, or just remove immediately if that’s acceptable.
Selecting/Playing a Track: Clicking on a track in the list should immediately play that track (and stop whatever was playing). The UI response: the newly selected track entry should highlight (to show it’s now playing). We can highlight by changing its background color or adding an indicator icon (like a playing speaker icon or equalizer animation next to it). A simple highlight: e.g., a slightly brighter or accented background rectangle behind the active track. This highlight should be updated whenever the track changes (like when one finishes and auto-advances to next).
We might also show a currently playing icon next to the active track’s name – for instance, a small equalizer bar animation or a play icon. This is optional but provides a quick visual of what’s playing especially if the user collapsed metadata and is just looking at playlist.
If we implement grouping or multiple file loads, maybe the playlist could show folder or album grouping, but likely not needed here.
Style: The playlist panel shares style with the metadata panel (background color, typography). It likely has the same width when open (~250px on desktop). The text entries should use the base font in a readable size (14px perhaps). The track title might be slightly bold or just regular if we want all items uniform (with the playing one bold as a highlight). Secondary text (artist/duration) can be smaller and/or a slightly muted color.
Each list item can have some padding (say 8px vertically and 12px horizontally) to ensure the text isn’t cramped. We can separate items with a thin divider line (1px line between each, in a very low-contrast color like #444 on dark or #ccc on light) or use alternating row background shading (e.g., alternate between two very close shades of gray) to delineate items subtly. Alternatively, just enough spacing and a consistent alignment might be fine without explicit dividers, to maintain the clean look.
The background of the playlist panel as a whole is the same concept as metadata panel – neutral, slightly offset from main background. If the accent color is used anywhere, it could be for the highlight or selection of tracks, or for the remove buttons (like a red X icon for delete).
Icons: The drag handle icon can be a simple stacked line icon in a muted color (so it doesn’t draw too much attention), maybe only a few pixels from the left edge. The remove (X) icon could be small (maybe 12px) at the far right of the item line. We should ensure these icons don't overlap text; there should be space reserved for them. For example, list item layout could be: [Handle icon][Track Title + possibly artist][Duration][Remove icon], each in its zone. However, to keep it simpler, maybe no duration to avoid too many columns; or if we do include duration, we can right-align it and have remove icon overlay on the far right of that same column when hovering.
We will use consistent iconography for these symbols (matching the style of others – perhaps also line-based icons).
Collapsibility: Like the metadata panel, the playlist panel is collapsible.
On desktop, it might collapse to a thin strip on the right side. This strip could show a “Playlist” icon (like a list or queue icon) rotated vertically or simply as a small icon centered in the strip. Clicking expands it out. Or we can have an overlay button at the bottom or top right corner that toggles it.
Keyboard shortcut P toggles it, and when that happens an animation plays (slide out/in).
On smaller screens, the playlist is typically hidden by default. On a tablet, perhaps you can toggle it similar to metadata panel (one at a time perhaps; if one opens, maybe hide the other to not overcrowd).
On a phone, the playlist is a full-screen or nearly full-screen view when opened, similar to the metadata info modal. It might present the list in a larger, scrollable list. We might combine current track info at top of that view with the list below, or just list since the user can get track info separately. A simple approach: tapping the playlist icon on a phone opens a new screen titled “Playlist” with a back button or X to close, listing tracks. This page can use the same list item style scaled up for mobile (with sufficient row height for touch). Reordering on mobile might be less discoverable, but we can still allow long-press drag.
Interactions:
The user should be able to clearly tell which track is playing now – via the highlight bar or icon mentioned.
They should be able to navigate: clicking an item jumps to it (we should maybe auto-close the playlist panel after choosing on mobile, but on desktop leave it open).
Removing an item should perhaps pause if you removed the currently playing track (or skip to next). We could warn if they try to remove the currently playing track (“Removing current track will stop playback or skip to next.”) but maybe just handle it gracefully (skip to next track automatically).
If the user loaded multiple files at once, the playlist shows them in that order. They can rearrange if they want a different order. We should ensure the currently playing track stays visible (if the list is scrolled, maybe auto-scroll to that item).
Possibly an “Add Files” button or area could exist in the playlist panel as well (like a plus icon at top or bottom to add more tracks), but since we have the main file open mechanism, it might be redundant. Still, a little “+ Add” at the bottom of playlist could be handy, which just invokes the file picker again. That could be a text button with plus icon, styled minimally.
Additionally, maybe a “Clear Playlist” button to remove all tracks (maybe in a context menu or at bottom with a trash icon). Only include if needed to avoid clutter. If included, it should ask confirmation or be placed where accidental click is unlikely.
By designing the playlist panel with these details, we ensure it’s not just functional but also visually integrated. It turns the app into a mini music player with a clear queue, which users will find familiar. Despite the additional complexity, we keep it organized and clean – no garish colors or heavy elements, just a structured list with slight highlights. The playlist, like the rest of the app, follows the modern style guide: consistent typography, spacing, and interactive feedback (e.g., list item highlight on hover selection in desktop, maybe slight elevation effect if clicked).
Keyboard Shortcuts
For power users and convenience, several keyboard shortcuts are defined. These allow quick control of playback and toggling of UI panels. They are chosen to be mnemonic and not conflict with standard browser keys:
Spacebar – Play/Pause: Toggles playback of the current track or input. (If in a text input field, space would normally input a space, but we can ensure no text fields are focused to capture this. Most players use Space as play/pause when focused.)
Arrow Left / Right – Previous/Next Track: Hitting the Left Arrow will jump to the previous track in the playlist (or restart current track if within the first few seconds, similar to common music app behavior). Right Arrow goes to the next track. These provide quick track navigation without clicking the buttons.
M – Toggle Metadata Panel: Press “M” to show or hide the Metadata sidebar. This is a quick way to peek at track info. When toggled, the panel slides in or out accordingly. If the app is in a state (mobile) where metadata opens as a modal, this shortcut would trigger that modal.
P – Toggle Playlist Panel: Press “P” to open/close the Playlist sidebar. Similarly, on mobile it could bring up the playlist screen. This is handy for quickly checking or changing the next track.
S – Open Spectrogram Settings: Press “S” to open the spectrogram settings module (the panel with theme/scale options). This is a convenient shortcut to avoid clicking the gear icon. Likely it opens as a modal and focuses it.
Ctrl/Cmd + Shift + S – Snapshot: This combination captures the current spectrogram image (same as clicking the snapshot camera icon). We chose a more complex chord for this to avoid accidental presses (and it’s somewhat analogous to “Save” but with Shift to indicate it’s a special save of an image).
Up Arrow / Down Arrow – Volume Up/Down: Pressing the Up arrow increases volume incrementally (for example, 5% steps) and Down arrow decreases volume. If volume hits 0, maybe that’s effectively mute; if it hits 100%, that’s max. We will ensure the volume slider in the UI moves accordingly when these keys are used. This provides an easy way to adjust volume without using mouse. (We avoid using general letter keys for volume to not conflict; arrows are intuitive like a media key.)
Possibly others (for completeness, we might consider Mute on “M” as well, but M we used for metadata; often “M” is mute in players, but we gave it to metadata. However, since metadata can be toggled with that icon too, maybe it’s okay. Alternatively, we could reassign metadata toggle to “I” for info, and use “M” for mute. But given the spec provided uses M for metadata, we keep that. The user can still mute via volume icon or bring volume to 0.)
No shortcut was given for Stop explicitly, but maybe Shift+Space or something could be stop. We might not complicate since Stop is rarely used as keyboard (one could just press Space to pause). If needed, could use “Shift+S” but S we used. So likely no direct key for stop by default.
Esc – a general behavior: hitting Escape could close any open panel or modal (settings, metadata, playlist). This is a common UX pattern we should implement. Not listed in spec, but as a suggestion it improves keyboard control.
All shortcuts should be documented in a help screen or tooltip somewhere (perhaps in a “Help” section or as part of settings). We should ensure they don’t interfere with browser defaults (e.g., Space normally scrolls page if not handled, but since our app might capture it and prevent default when appropriate). Also, these only work when the app has focus. From a design perspective, keyboard shortcuts don’t have a visual component unless we add hints. We might incorporate subtle underlines or letters in the UI (like underlining M in a menu title, etc.) but that’s more desktop app style than web. Instead, we might include a “Shortcut Cheat Sheet” accessible via a help icon or maybe shown on first load (e.g., an overlay listing keys: could be something the user can open). If we do, that cheat sheet should be in the same style: a small modal with a list of shortcuts, using the same typography and spacing, perhaps with a keyboard icon graphic. The key goal is these shortcuts make the app efficient to use for those who remember them, while all functions remain accessible via mouse/touch as well. We maintain consistency (using first letters that make sense, etc.) and ensure coherence (the letter choices somewhat match the panel names).
Design Language & Style
The visual design language of the app is unified and modern, aligning with both contemporary UI trends and the minimalist Bauhaus-inspired principles of functional beauty
medium.com
medium.com
. Below we detail the design specifics: color scheme, typography, iconography, spacing, and interactive effects, to ensure every element looks part of the same family and contributes to an intuitive, attractive UI. Color Palette:
Neutral Base: The interface uses neutral gray tones as a foundation. The exact shade depends on theme (dark or light). For the default dark theme, a near-black (#121212 or #181818) is used for backgrounds (spectrogram background, main background) to let the colorful spectrogram content pop and to reduce eye strain. Panels might use a slightly lighter dark (e.g., #242424) to distinguish their surface. In light theme, a very light gray or white (#FFFFFF background, #F0F0F0 panels) keeps things clean and bright. These base colors are purposefully desaturated and unobtrusive.
Accent Colors: Each theme has accent colors for interactive elements and highlights. We choose accent colors that are modern and have sufficient contrast against the base. For example:
In a default theme (dark mode), an accent could be a vibrant blue or teal (e.g., #00BCD4 or #1DB954 (Spotify green) if we want a green). This accent would be applied to things like the play button when hovered, the slider fill, the currently playing track highlight, etc. Blue/teal on dark gives a nice neon-esque glow without being garish.
The neon theme obviously might use multiple neon colors for spectrogram, but UI elements (buttons, text) still would pick one primary accent for consistency (maybe electric blue #00ffff or hot pink #ff4081, etc., depending on chosen scheme).
The high contrast theme might use pure primary colors (like red for accent on black/white background).
Feedback Colors: Success or confirmation actions could use a green check or subtle green tint for messages; error states (like file error) could use a red accent (e.g., text or icon).
Background vs Foreground Contrast: All text is chosen to be high contrast against its background. On dark backgrounds, we mainly use light text (white, or light gray for secondary text). On light backgrounds, we use dark text (black or dark gray). The spectrogram’s own colors are chosen also with contrast in mind; for instance, if background is black, even dark blue for low intensities will be visible, and bright yellow for loud is extremely visible. We will avoid combinations like pure red on black for text (low readability), etc.
We ensure accessibility: We target at least WCAG AA contrast (4.5:1 for normal text). For example, if panel background is #242424 and text is #cccccc, that’s likely okay for large text but might be borderline for small text – maybe use #e0e0e0 for small text to be safe. In light mode, light gray text (#888) on white might fail contrast, so we stick to darker gray (#555 or stronger) for any text.
Typography:
We use a clean, modern sans-serif font throughout – suggested ones include Inter, Roboto, or Helvetica Neue. These fonts have good readability on screens and a neutral, contemporary look that matches our design. Typography is critical as Bauhaus design also emphasized clarity in text
medium.com
.
Font Sizes & Hierarchy: We establish a typographic scale:
Large titles (like the app title in header or track title in metadata) ~18px to 20px, bold weight.
Regular body text (like artist name, button labels, panel content) ~14px or 15px, normal weight.
Small text (like footnotes, time stamps, minor metadata) ~12px, maybe medium or normal weight.
On high DPI mobile screens, these may be slightly larger in actual device pixels to be legible (we can use relative units or media queries to bump font-size on small devices).
Weight & Style: Generally use Medium or Semi-Bold for important labels (buttons, headings) and Regular for normal text. Avoid italics or decorative styles as they clash with the clean design, except perhaps for notations if needed (likely not needed here). All-caps could be used for small labels or button texts if it fits style, but likely we stick to Title Case or Sentence case for a friendlier appearance.
Line Heights and Spacing: Use sufficient line height (e.g., 1.4em for body text) so text isn’t cramped. In lists like playlist, a slightly tighter line height could be used if we need to fit more, but better to keep consistency for readability.
If using web fonts (Inter/Roboto), ensure they load gracefully (maybe include a system fallback to sans-serif).
The typography will be consistent across devices, potentially scaled slightly larger on smaller screens for readability as needed.
Icons & Graphics:
All icons used in the app (play, pause, stop, next, prev, volume, mic, settings, info, playlist, etc.) come from a uniform icon set or are custom-designed to match each other. We opt for a minimalist icon style: either outline icons (linear, stroke-based icons) or glyph icons (solid filled shapes), but we keep them consistent. For example, we might use Material Design Icons (which can be either filled or outlined). A Bauhaus-inspired approach might lean towards very geometric forms: circles, triangles, and lines with consistent stroke widths.
E.g., the Play icon is a triangle that fits well in a circle shape (for its button). The Next/Prev icons are triangles with a bar, matching the stroke thickness. The microphone icon is an outline of a classic mic shape that’s easily recognized.
Icons are typically rendered in a single color (no multicolor illustrations) – usually the same as text (white for dark theme, etc.) unless active. To indicate an active or selected state, we might change the icon’s color to the accent or fill its shape. For instance, the mic icon when active might become filled with the accent color or have a small “on” indicator dot.
Icon Size & Placement: We’ve mentioned sizes (most around 24px, main play 32px). They should be aligned nicely with adjacent text or elements. Use CSS to vertical-align them center in their containers.
If using SVGs, we can easily recolor on hover via CSS (by targeting fill property).
Also consider using slight shadows or glows on icons when needed for contrast. For example, a white icon on a bright part of the spectrogram (if the icon floats over it) might need a tiny dark shadow to remain visible. In our design, most icons are on solid backgrounds (header, footer, panels), so not an issue. But the camera icon we considered overlaying on spectrogram might occasionally overlay bright content – thus we can put a translucent circle behind it or a shadow effect for visibility.
Controls & Buttons:
All interactive controls (buttons, sliders, toggles) have a consistent style that’s modern and touch-friendly:
Buttons (play, etc.): Likely icon-only buttons in this app. We give them a default state (no border, just the icon), and on hover or focus, they might show a light background highlight (e.g., a semi-transparent white or gray circle if background is dark). On active click, maybe they depress. If we had text buttons (like “Add” or “Close”), we’d style them minimally (flat design, with accent color text or background on hover).
Toggles (like theme toggles or checkboxes in settings): Use modern toggle switches or checkboxes with custom styling. For instance, a checkbox could be a custom one where checked state is an accent-colored check mark in a rounded box. Or a toggle switch (like a small slider) for on/off options. Keep them lightweight (no heavy 3D look, just flat or subtle shadow).
Sliders (volume, any others): We design sliders with a thin track (2px height or so) in a low-key color and a knob that’s easy to see and grab. The knob can be a small circle with a border or shadow to stand out from background. We already discussed the seek bar which is a special slider. Volume slider can be similarly styled but smaller.
Panels & Modals: When panels (like settings or modals like playlist on mobile) appear, they have gentle rounded corners (maybe 8px radius) to fit the soft design language. The drop-shadows for modals can be subtle (e.g., 0 4px 12px rgba(0,0,0,0.3)) to lift them above content. This layering adds depth without clutter.
Hover and Touch Feedback: Every clickable item gives feedback:
Buttons: change color or opacity on hover (for mouse), and on touch (active state) maybe remain highlighted for a short time.
List items: could highlight on hover with a slight background tint. On touch, might briefly flash or remain highlighted until release.
Sidebar toggle strips: maybe an arrow icon on it rotates or the strip glows on hover.
We can even have the album art tile highlight if clicked (though album art isn’t interactive by spec, but if we ever allow clicking it to maybe enlarge or open file location, we’d give feedback).
We avoid any gaudy effects – feedback is subtle but noticeable: e.g., a 10% lighter background on hover, or a faint shadow appearing. This keeps with the polished modern feel.
Spacing & Grid:
The design heavily uses consistent spacing and alignment to achieve a coherent look. We likely adopt an 8px (or 4px) grid system for all margins/paddings:
Major sections separated by 16px or 24px gaps.
In-panel item spacing around 8px.
Button icon padding maybe 8px.
We ensure that elements line up neatly: for example, in the footer, icons vertically centered, equal gaps between them. In sidebars, text aligned left with a margin indent perhaps if there's an icon.
The Bauhaus influence of grid and order
medium.com
 is reflected in how everything is laid out with purpose. For instance, the left edge of the album art could align with left edge of track title text below (creating a clean vertical line). The right edge of metadata text maybe aligns with something else below. These subtle alignments make the design look professional. We can achieve this by using container elements that span full width of the panel for each major piece and consistent padding.
Margins to edges of the window: we don't want content smashed against the browser edges. So even if the spectrogram goes full width on mobile, we might have a small padding (like 4-8px) at the edges or the canvas might not render to the absolute edge if that interferes with device UI. On desktop full-screen, a small padding just ensures nothing feels cut off.
The footer and header likely span edge to edge by design (so the app feels full-bleed) but the content inside them has padding.
Animations & Transitions:
Animations are used to enhance smoothness and provide context, but they are kept efficient and tasteful:
Panel transitions (metadata, playlist, settings) are animated as described: sliding in/out with easing, maybe 300ms duration. Use CSS transitions or transform for performance. The animation should not be too slow or it will frustrate users; it should just make the appearance/disappearance less abrupt.
Hover animations on buttons (like slight grow/shrink or color fade) can be ~150ms ease-in-out.
The spectrogram itself is continuously animating by its nature. We make sure this is implemented in a way (maybe using canvas/WebGL double-buffering) that it doesn’t glitch even as other UI elements animate or update.
If theme is switched by the user, we might animate the color changes: for instance, fade the background color and text color over 0.5s rather than instant flash, to make it a pleasant transition.
Micro-interactions: e.g., when dragging a playlist item, that item could slightly enlarge or lift (shadow appears) and on drop the reordering is highlighted (maybe flash background of the moved item briefly to show where it landed).
Snapshots: as mentioned, maybe a quick white flash of the spectrogram area (50ms fade in/out) to simulate a camera flash – this gives a satisfying confirmation of the action.
Volume change: some apps show a small popup or just rely on the slider movement. We likely just show slider movement and maybe update the icon (like show mute icon if volume = 0, etc.) as feedback.
All animations should be lightweight so as not to lag low-power devices. Using CSS where possible (GPU-accelerated) and avoiding heavy JS reflows is ideal. We also ensure that animations can be disabled or reduced if the user’s OS is set to reduce motion (respect prefers-reduced-motion: reduce by providing a simplified, non-animated transition for those who need it).
Overall Aesthetic:
The combination of the above elements yields an aesthetic that is modern, minimalist, and functional. Borrowing from Adobe Audition, we have a professional dark UI with vibrant visualizations, but we trim down any unnecessary clutter. From Bauhaus, we incorporate the idea that every UI element serves a purpose and is visually streamlined – “clean lines and an absence of ornamentation”
medium.com
. The interface should feel cohesive: nothing looks like it’s from a different design language. For example, we wouldn’t mix neon cyberpunk buttons with skeuomorphic toggles; everything is flat design with subtle depth only where needed (like shadows on panels). Users, whether they are audio engineers or casual listeners, should find the interface inviting due to its clarity and consistency, yet powerful and complete in the feature set.
Extra Suggestions & Features
Beyond the core specifications, here are a few additional suggestions and details that could further improve the application’s design and functionality:
Custom Color Maps (Advanced Theming): For users who want more control, allow custom spectrogram color maps. This could be part of the settings panel: a small interface to pick gradient colors or select from presets (e.g., “Classic Heatmap”, “Grayscale”, “Inferno”, etc.). A simple UI might show two or three color pickers representing low, mid, high intensity colors; the app then interpolates a gradient. Users can thus create a spectrogram palette that suits their taste or specific needs (for example, a grayscale only map for print publications, or a specific contrasty palette for scientific analysis). We need to ensure the UI remains user-friendly: maybe hide these advanced options under an expandable "Advanced" subsection in settings so novice users aren’t overwhelmed. If implemented, this feature underscores the app’s professional capability. The design should preview the new color map immediately on the legend or a small sample patch so users see what they are making.
Data Export Options: In addition to snapshot images, we provide ways to export the underlying data:
A button or menu option “Export Data” can initiate download of CSV or JSON containing the spectrogram matrix or audio analysis data. For example, CSV could have columns for frequency bins and time, or JSON with an array of spectral frames. The exact format can be explained in documentation.
The UI for this might be in the settings modal or perhaps a small download icon next to snapshot icon. To avoid clutter, possibly a single “Export” button that when clicked, offers a dropdown of options: “Download Spectrogram Image (PNG)”, “Export Spectral Data (CSV)”, “Export Audio Waveform Data (JSON)”, etc. This could be a contextual menu.
After export starts or completes, provide feedback (“Data exported successfully”). If it’s quick, maybe just a small toast. If it takes time (very long track analysis), perhaps a progress bar or spinner should be shown.
This feature would appeal to advanced users (e.g., researchers). Ensure the design for it is consistent with others (same button styles, etc.) and doesn’t accidentally get triggered by casual users (hence maybe keep it slightly tucked away in settings).
Offline & Installation (PWA features): As a PWA, the app should be installable and offline-capable:
App Icon & Splash: Design an app icon that represents the spectrogram app – perhaps a simple wave or spectrogram icon in the app’s accent colors. The icon should be flat and modern (fits with iOS and Android styles) and recognizable at small sizes. A splash screen shown during launch (on mobile PWA) could just be the app logo centered on a background in the app’s base color, to maintain branding.
Responsive behavior offline: The UI should detect if it’s offline when trying to load a file or use mic (if any such limitation) and show a gentle error or info (“You’re offline. Live streaming features unavailable” or so). Since most functionality is local (files, mic), offline is mostly fine, but if any help content or CDN fonts are used, ensure they’re cached.
The design doesn’t explicitly change offline, but maybe a small offline indicator icon could be shown if relevant (not essential though).
Also consider a full-screen mode toggle (especially on desktop, a small button to make the spectrogram go fullscreen, hiding browser UI – can be done via Fullscreen API). This can maximize the viewing area. The button could be two arrows expanding icon, placed maybe in a corner. On activation, it hides header/footer except maybe a small floating close-fullscreen button. This is an optional nice-to-have for those who want an immersive view.
Interactive Spectrogram Features: We can propose some interactive additions:
Zoom & Pan: Perhaps allow the user to zoom into the spectrogram frequency axis (especially if using log scale, might want to focus on a range). This could be done with pinch-zoom on touch devices or scroll wheel on desktop. If implemented, an indicator of zoom level or a reset zoom button would be needed. This is advanced, but worth considering for users who want to inspect details.
Freeze/Pause Display: In addition to snapshot, a simple freeze button could pause the live spectrogram (stopping scrolling but leaving data on screen) so user can inspect something. Then pressing it again resumes live. This is somewhat achieved by the Pause (if we treat pause as stopping audio input processing, but if mic is live, pause might stop updating but mic still capturing). A dedicated freeze could be helpful if one wants to pause without actually stopping audio (for instance in mic mode maybe you want to pause display but continue capturing data for a moment). The UI for freeze could be a small pause icon in corner of spectrogram separate from play/pause (or reuse play/pause if play/pause tied to input). Could complicate, so it’s just a thought.
User Guidance & Help: Provide a way for new users to learn the UI quickly:
Maybe a tutorial tooltip on first launch highlighting key areas: e.g., “This is the spectrogram display – it shows frequencies over time. Try clicking the play button to start.” etc. This could be a one-time overlay with arrows and short text, which the user can skip. Not mandatory, but helps adoption.
A Help icon (a question mark) could be placed in the header or settings, which when clicked shows a summary of controls, shortcuts, and tips. It can reuse the same modal styling.
We should document the shortcuts there for easy reference.
Coherent Experience Across Platforms: Because PWA runs on different devices, we ensure that the touch interactions are as refined as desktop:
e.g., On mobile, swiping left/right on spectrogram could optionally seek in track (some audio apps allow scrubbing by swiping on waveform). If that is considered, implement carefully to not conflict with other gestures (maybe only active if a certain mode is on).
Haptic feedback on mobile (if accessible via web API) when pressing play or toggling could add a tactile feel (this is a detail beyond pure UI design, but consider if technology allows).
Performance Considerations in Design: While not directly visual, mention that the design has considered performance – ensuring that heavy visualizations are efficient (WebGL or Canvas acceleration) and that large images (album art) are lazy-loaded or scaled down appropriately. This affects user experience (a smooth UI is part of good design). So design-wise we might choose to limit how much history the spectrogram shows to avoid memory bloat (maybe only last N seconds visible, older data purged, because infinitely scrolling could exhaust memory if left forever). This invisible detail ensures the app remains fluid and responsive which is crucial for a good user experience.
Finally, all these elements come together to create a cohesive application. The design is simple but complete – it has all needed components, each styled in a coherent way. By not leaving any detail to chance, we ensure the final product looks polished: from the exact shade of gray in the background, to the padding around icons, to the way a panel slides out – everything follows the same design language. The end result will be a modern spectrogram viewer PWA that is not only powerful and feature-rich but also delights users with its clarity and aesthetic uniformity, echoing both the practicality of professional audio tools and the timeless principles of good design.